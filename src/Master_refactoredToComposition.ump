mixset Attribute { 
// Fragment source file: UmpleInternalParser_CodeClass.ump
// Line : 5855
 class UmpleInternalParser { mixset Method {
      void checkDefaultedNameConflict(){
        Map<String, CodeTranslator> allTranslators = model.getAllTranslators();
        HashSet<String> generatedMethods = new HashSet<String>();
        for(String langName : allTranslators.keySet()){
          CodeTranslator t = allTranslators.get(langName);

          for(UmpleClass aClass : model.getUmpleClasses()){
            generatedMethods.clear();

            for(Attribute aAttr : aClass.getAttributes()){
              String modifier = aAttr.getModifier();

              // Can add more!
              if(!"internal".equals(modifier)){
                addToGeneratedMethodMap(generatedMethods, aClass.getName(), t, "getMethod", aAttr);
                addToGeneratedMethodMap(generatedMethods, aClass.getName(), t, "setMethod", aAttr);
              }

              if("defaulted".equals(modifier)){
                addToGeneratedMethodMap(generatedMethods, aClass.getName(), t, "getDefaultMethod", aAttr);
              }
            }
          }
        }
      }

      boolean addToGeneratedMethodMap(HashSet<String> generatedMethods, String className, CodeTranslator t, String translatingLabel, Attribute aAttr){
        String generatedMethodName = t.translate(translatingLabel, aAttr);

        if(generatedMethodName != null && !"".equals(generatedMethodName) && !generatedMethodName.startsWith("UNKNOWN ID")){

          boolean success = generatedMethods.add(generatedMethodName);
          if(!success){
            getParseResult().addErrorMessage(new ErrorMessage(48,aAttr.getPosition(), aAttr.getName(), className, generatedMethodName));
            return false;
          }

        }
        return true;
      }

    } } 

}

mixset Method { 
// Fragment source file: Master.ump
// Line : 5856
 class UmpleInternalParser { void checkDefaultedNameConflict(){
        Map<String, CodeTranslator> allTranslators = model.getAllTranslators();
        HashSet<String> generatedMethods = new HashSet<String>();
        for(String langName : allTranslators.keySet()){
          CodeTranslator t = allTranslators.get(langName);

          for(UmpleClass aClass : model.getUmpleClasses()){
            generatedMethods.clear();

            for(Attribute aAttr : aClass.getAttributes()){
              String modifier = aAttr.getModifier();

              // Can add more!
              if(!"internal".equals(modifier)){
                addToGeneratedMethodMap(generatedMethods, aClass.getName(), t, "getMethod", aAttr);
                addToGeneratedMethodMap(generatedMethods, aClass.getName(), t, "setMethod", aAttr);
              }

              if("defaulted".equals(modifier)){
                addToGeneratedMethodMap(generatedMethods, aClass.getName(), t, "getDefaultMethod", aAttr);
              }
            }
          }
        }
      }

      boolean addToGeneratedMethodMap(HashSet<String> generatedMethods, String className, CodeTranslator t, String translatingLabel, Attribute aAttr){
        String generatedMethodName = t.translate(translatingLabel, aAttr);

        if(generatedMethodName != null && !"".equals(generatedMethodName) && !generatedMethodName.startsWith("UNKNOWN ID")){

          boolean success = generatedMethods.add(generatedMethodName);
          if(!success){
            getParseResult().addErrorMessage(new ErrorMessage(48,aAttr.getPosition(), aAttr.getName(), className, generatedMethodName));
            return false;
          }

        }
        return true;
      } } 

}


mixset FeatureModel { 
// Fragment source file: Umple.ump
// Line : 1327
use feature/FeatureModel.ump;

// Fragment source file: UmpleInternalParser_Code.ump
// Line : 556
use UmpleInternalParser_CodeRequireStatement.ump;

// Fragment source file: Master.ump
// Line : 86
require [Mixset];

}

mixset AspectInjection { 
// Fragment source file: Umple_CodeMethod.ump
// Line : 338
class CodeInjection
  {
    public CodeInjection(String a, String b, String c, UmpleClassifier d)
    {
      this(a,b,new CodeBlock(c), d);
    }
    public void setCode(String str)
    {
      snippet.setCode(str);
    }
    public String getCode()
    {
      return snippet.getCode();
    }
    public String getConstraintCode(CodeTranslator gen)
    {
      return StringFormatter.format(gen.translate("Closed",constraintTree),getCode());
    }
    public void setCode(String lang, String code)
    {
      snippet.setCode(lang, code);
    }
    public String getCode(String lang)
    {
      return snippet.getCode(lang);
    }
  }

// Fragment source file: UmpleInternalParser_CodeMixset.ump
// Line : 483
class CodeInjection{
    String injectionlabel = "";
    boolean codeBlockProcessed = false;

    boolean hasCodeLabel()
    {
      return ! injectionlabel.equals("");
    }
  }

  class CodeBlock{
    depend java.util.regex.Matcher;
    depend java.util.regex.Pattern;

    public ArrayList<String> getCodeWithLabels(String codesKey) {
      ArrayList <String> codeLabels = new ArrayList<String>();
      String codeToLockAt = getCode(codesKey);
      ArrayList<String> codeWithLabels = new ArrayList<String>();
      Pattern labelPatternToMatch = Pattern.compile("(\\S+):");
      Matcher matcher = labelPatternToMatch.matcher(codeToLockAt);
      int lastMatchedIndex=0;
      while (matcher.find()) {
        String codeBeforeLabel = codeToLockAt.substring(lastMatchedIndex, matcher.start());
        if(!codeBeforeLabel.equals(""))
          codeWithLabels.add(codeBeforeLabel);
        codeWithLabels.add(matcher.group()); //add the label itself to the source code.
        codeLabels.add(matcher.group().replaceFirst(":","")); // remove colon and add it the list of labels 
        lastMatchedIndex = matcher.end();
      }
      // This for last label, to add the code after last matched label 
      String codeAfterLastLabel =codeToLockAt.substring(lastMatchedIndex); 
      codeWithLabels.add(codeAfterLastLabel);
      return codeWithLabels;
    }

  }

  class MethodBody
  {
    depend java.util.regex.Matcher;
    depend java.util.regex.Pattern;

    public static int indexOfMixsetClosingBracket(String strInput) {
    int closeIndex = 0;
    int numOfclosingBracket=0;
    for(int i = 0; i< strInput.length();i++)
    {
      char currentChar = strInput.charAt(i);
      if(currentChar =='{')
      numOfclosingBracket++;
      else if(currentChar == '}')
        {
          numOfclosingBracket--;
          if(numOfclosingBracket==0)
            {
              closeIndex = i+1;
              break;
            }
        }	
    }
    return closeIndex;
  }
  public  ArrayList<MixsetInMethod> getMixsetsWithinMethod(){
    return getMixsetsFromCode(this.getCodeblock().getCode());
  }
  public static ArrayList<MixsetInMethod> getMixsetsFromCode(String codeToLockAt){
    ArrayList<MixsetInMethod> mixsetInsideMethodList = new ArrayList<MixsetInMethod>();
    Pattern labelPatternToMatch = Pattern.compile("mixset\\s+\\S+\\s+\\{"); // to detect mixset def.
    Matcher matcher = labelPatternToMatch.matcher(codeToLockAt);
    while (matcher.find()) {
      String mixsetDefPlusAfterCode = codeToLockAt.substring(matcher.start());
      // mixset def. + the code after the mixset def.
      int indexOfMixsetClosingBracket = matcher.start() + indexOfMixsetClosingBracket(mixsetDefPlusAfterCode);
      String mixsetBodyWithDef = codeToLockAt.substring(matcher.start(),indexOfMixsetClosingBracket);
      // get the name of the mixset
      String mixsetName = matcher.group().replace("mixset", "").replace("{", "").trim(); 
      MixsetInMethod mixsetInsideMethod = new MixsetInMethod(mixsetName,matcher.start(),indexOfMixsetClosingBracket,mixsetBodyWithDef);
      
      // place inner method in their right position.
      for(MixsetInMethod tempMixsetInMethod:mixsetInsideMethodList)
      {
        if(mixsetInsideMethod.getStartPositionIndex() > tempMixsetInMethod.getStartPositionIndex()
            & mixsetInsideMethod.getEndPositionIndex() < tempMixsetInMethod.getEndPositionIndex())
        { 
          // a nested mixset should be bounded by its close parent mixset 
          mixsetInsideMethod.setParentInnerMixset(tempMixsetInMethod);
          tempMixsetInMethod.addChildMixset(mixsetInsideMethod);
        }
      }
      // a nested mixset should not add here. 
      if(mixsetInsideMethod.getParentInnerMixset() == null) // its not bounded by another mixset 
      {
        mixsetInsideMethodList.add(mixsetInsideMethod);
      }
    }
    return mixsetInsideMethodList;
  }
  }

// Fragment source file: UmpleInternalParser_Code.ump
// Line : 560
use class/UmpleInternalPraser_CodeInjection.ump;

}

mixset SuperCodeGeneratorGenerator { 
// Fragment source file: Generator.ump
// Line : 123
use generators/Generator_SuperCodeGenerator.ump;

}

mixset CodeGenerator { 
// Fragment source file: Generator.ump
// Line : 88
use generators/Generator_Code.ump;

}

mixset UmpleGenerator { 
// Fragment source file: Generator.ump
// Line : 89
use generators/Generator_CodeUmple.ump;

}

mixset RubyGenerator { 
// Fragment source file: Generator.ump
// Line : 91
use generators/Generator_CodeRuby.ump; 
  use RubyGeneratorIntMixset;

}

mixset JavaGenerator { 
// Fragment source file: Generator.ump
// Line : 94
use generators/Generator_CodeJava.ump;

}

mixset RTCppGenerator { 
// Fragment source file: Generator.ump
// Line : 95
use generators/Generator_CodeRTCpp.ump;

}

mixset PhpGenerator { 
// Fragment source file: Generator.ump
// Line : 96
use generators/Generator_CodePhp.ump;

}

mixset Uigu2Generator { 
// Fragment source file: Generator.ump
// Line : 97
use generators/Generator_CodeUigu2.ump;

}

mixset SqlGenerator { 
// Fragment source file: Generator.ump
// Line : 98
use generators/Generator_CodeSql.ump;

}

mixset UmpleSelfGenerator { 
// Fragment source file: Generator.ump
// Line : 99
use generators/Generator_CodeUmpleSelf.ump;

}

mixset USEGenerator { 
// Fragment source file: Generator.ump
// Line : 100
use generators/Generator_CodeUSE.ump;

}

mixset EcoreGenerator { 
// Fragment source file: Generator.ump
// Line : 101
use generators/ecoreGenerator/ecoreGeneratorConfig.ump;

}

mixset TestGenerator { 
// Fragment source file: Generator.ump
// Line : 102
use generators/Generator_CodeTest.ump;

}

mixset PapyrusGenerator { 
// Fragment source file: Generator.ump
// Line : 103
use generators/papyrus/Generator_CodePapyrus.ump;

}

mixset XmiGenerator { 
// Fragment source file: Generator.ump
// Line : 104
use generators/xmi/Generator_CodeXmi.ump;

}

mixset TextUmlGenerator { 
// Fragment source file: Generator.ump
// Line : 105
use generators/Generator_CodeTextUml.ump;

}

mixset ScxmlGenerator { 
// Fragment source file: Generator.ump
// Line : 106
use generators/Generator_CodeScxml.ump;

}

mixset CodeGvClassTraitDiagramGenerator { 
// Fragment source file: Generator.ump
// Line : 112
use generators/Generator_CodeGvClassTraitDiagram.ump;

}

mixset EventSequenceGenerator { 
// Fragment source file: Generator.ump
// Line : 109
use generators/Generator_CodeEventSequence.ump;

}

mixset FeatureDiagramCo { 
// Fragment source file: Generator.ump
// Line : 113
use generators/featureDiagramGenerator/FeatureDiagramConfig.ump;

}

mixset EntityRelationshipCon { 
// Fragment source file: Generator.ump
// Line : 114
use generators/entityRelationshipDiagramGenerator/entityRelationshipConfig.ump

}

mixset SimulateGenerator { 
// Fragment source file: Generator.ump
// Line : 117
use generators/Generator_CodeSimulate.ump;

}

mixset YumlGenerator { 
// Fragment source file: Generator.ump
// Line : 118
use generators/Generator_CodeYuml.ump;

}

mixset XtextGenerator { 
// Fragment source file: Generator.ump
// Line : 119
use generators/Generator_CodeXtext.ump;

}

mixset JsonGenerator { 
// Fragment source file: Generator.ump
// Line : 120
use generators/Generator_CodeJson.ump;

}

mixset JsonMixedGenerator { 
// Fragment source file: Generator.ump
// Line : 121
use generators/Generator_CodeJsonMixed.ump;

}



mixset GvStateDiagramGenerator { 
// Fragment source file: Generator.ump
// Line : 107
use generators/statemachineDiagramGenerator/stateMachineDiagramConfig.ump;

}

mixset StateTableGenerator { 
// Fragment source file: Generator.ump
// Line : 108
use generators/Generator_CodeStateTables.ump;

}

mixset SuperGvGeneratorGenerator { 
// Fragment source file: Generator.ump
// Line : 124
use generators/Generator_SuperGvGenerator.ump;

}

mixset HtmlGenerator { 
// Fragment source file: Generator.ump
// Line : 125
use generators/Generator_Html.ump;

}

mixset UmpleModelWalkerGenerator { 
// Fragment source file: Generator.ump
// Line : 126
use generators/Generator_UmpleModelWalker.ump;

}

mixset CodeAnalysisGenerator { 
// Fragment source file: Generator.ump
// Line : 127
use generators/Generator_CodeAnalysis.ump;

}

mixset AlloyGenerator { 
// Fragment source file: Generator.ump
// Line : 115
use generators/alloy/Generator_CodeAlloy.ump;

}

mixset NuSMVGenerators { 
// Fragment source file: Generator.ump
// Line : 116
use generators/NuSMV/nusmvGeneratorConfig.ump;

}

mixset NuSMVGenerator { 
// Fragment source file: nusmvGeneratorConfig.ump
// Line : 9
use generators/NuSMV/Generator_CodeNuSMV.ump;

}

mixset NuSMVOptimizerGenerator { 
// Fragment source file: nusmvGeneratorConfig.ump
// Line : 11
use generators/NuSMV/Generator_CodeNuSMVOptimizer.ump;

}

mixset SimpleMetricsGenerator { 
// Fragment source file: Generator.ump
// Line : 110
use generators/Generator_CodeSimpleMetrics.ump;

}

mixset CodeGvClassDiagramGenerator { 
// Fragment source file: Generator.ump
// Line : 111
use generators/Generator_CodeGvClassDiagram.ump;

}

mixset UmpleAnnotaiveToCompositionGenerator { 
// Fragment source file: Generator.ump
// Line : 128
use generators/Generator_CodeAnnotaiveToComposition.ump;

}

mixset RubyGeneratorIntMixset { 
}

mixset EoreGenerator { 
// Fragment source file: ecoreGeneratorConfig.ump
// Line : 7
class EcoreGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.util.*;
  depend cruise.umple.compiler.exceptions.*;

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  EcoreGenModel genModel = null;
  String output = "";
}

use generators/ecoreGenerator/Generator_CodeEcore.ump;

}

mixset StateDiagramGenerator { 
// Fragment source file: stateMachineDiagramConfig.ump
// Line : 7
use generators/statemachineDiagramGenerator/Generator_CodeGvStateDiagram.ump
  
  class GvStateDiagramGenerator
  {
    isA CodeGeneratorWithSubptions;
    depend java.io.*;
    depend java.util.*;
    depend cruise.umple.util.*;
    depend cruise.umple.compiler.exceptions.*;

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
    UmpleModel model = null;
    String output = "";
  }

}

mixset FeatureDiagramGenerator { 
// Fragment source file: FeatureDiagramConfig.ump
// Line : 9
use generators/featureDiagramGenerator/Generator_CodeGvFeatureDiagram.ump;

  class GvFeatureDiagramGenerator
  {
    isA CodeGeneratorWithSubptions;
    depend java.io.*;
    depend java.util.*;
    depend cruise.umple.util.*;
    depend cruise.umple.compiler.exceptions.*;
  }

}

mixset EntityRelationshipGenerator { 
// Fragment source file: entityRelationshipConfig.ump
// Line : 7
use generators/entityRelationshipDiagramGenerator/Generator_CodeGvEntityRelationshipDiagram.ump;

class GvEntityRelationshipDiagramGenerator
{
  isA SuperGvGenerator;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.util.*;
  depend cruise.umple.compiler.exceptions.*;
}

}




//*** 
//Fine-grained variability : 
 




mixset AspectInjection { 
  class UmpleInternalParser { 
    before Label_AspectInjection_110:analyzeDependentTokens(Token,UmpleTrait,int)
  {
      else if (t.is("beforeCode") || t.is("afterCode"))
      {
      //TODO should applied for traits
        analyzeInjectionCode(t,inTrait);
      }
    }  } 
} 


mixset AspectInjection { 
  class UmpleInternalParser { 
    before Label_AspectInjection_114:applyTraitProperties(UmpleClass,UmpleTrait)
  {
       // copy injection codes
       for (CodeInjection cj : inTrait.getCodeInjections()) {
               cj.setUmpleClassifier(inClass);
               inClass.addCodeInjection(cj);
       }
    }  } 
} 







mixset FeatureModel { 
  class UmpleInternalParser { 
    before Label_FeatureModel_148:parseMixsetNotUsedToken(Token)
  {
      //parse require statments. 
      analyzeRequireStatement(token, 2);
    }  } 
} 

