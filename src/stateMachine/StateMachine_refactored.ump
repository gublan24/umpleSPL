  class UmpleInternalParser {
    before Label_StateMachine_142:postTokenClassEnumerationAnalysis(UmpleClass)
    {
      // Check if the enumeration conflicts with any state machines, and if the enumeration is used as
      // event parameters
      for (StateMachine sm : uClass.getStateMachines()) {
        if (uEnum.hasSameName(sm.getName())) {
          // Enumeration Conflicts with State Machine Error
          getParseResult().addErrorMessage(new ErrorMessage(97,
                                                            uEnum.getPosition(),
                                                            uEnum.getName(),
                                                            "" + uEnum.getPosition().getLineNumber(),
                                                            sm.getName(),
                                                            uClass.getName()));
          return;
        }
        for (Event e : sm.getAllEvents()) {
          for (MethodParameter p : e.getParams()) {
            if (uEnum.hasSameName(p.getType()) && otherClass != null) {
              // Event Parameter Ambiguity Warning
              getParseResult().addErrorMessage(new ErrorMessage(103,
                                                                uEnum.getPosition(),
                                                                uEnum.getName(),
                                                                "" + uEnum.getPosition().getLineNumber(),
                                                                p.getName(),
                                                                e.getName(),
                                                                sm.getName(),
                                                                otherClass.getName()));
            }
          }
        }
      }
    }
  }



  class UmpleInternalParser {
    before Label_StateMachine_143:analyzeModelEnumInClass(UmpleClass,UmpleEnumeration)
    {
      // Check if the class's state machines conflict with the enumeration, and if any of its state
      // machine's events use the enumeration in their parameters
      for (StateMachine sm : uClass.getStateMachines()) {
        if (classUsesEnum) {
          if (uEnum.hasSameName(sm.getName())) {
            // Enumeration Conflicts with State Machine Error
            getParseResult().addErrorMessage(new ErrorMessage(97,
                                                              uEnum.getPosition(),
                                                              uEnum.getName(),
                                                              "" + uEnum.getPosition().getLineNumber(),
                                                              sm.getName(),
                                                              uClass.getName()));
            return;
          }
        }
        for (Event e : sm.getAllEvents()) {
          for (MethodParameter p : e.getParams()) {
            if (uEnum.hasSameName(p.getType())) {
              if (!classUsesEnum && uEnum.hasSameName(sm.getName())) {
                // Enumeration Conflicts with State Machine Error
                getParseResult().addErrorMessage(new ErrorMessage(97,
                                                                 uEnum.getPosition(),
                                                                 uEnum.getName(),
                                                                 "" + uEnum.getPosition().getLineNumber(),
                                                                 sm.getName(),
                                                                 uClass.getName()));
                return;
              }
              else {
                classUsesEnum = true;
              }
            }
          }
        }
      }
    }
  }


  class UmpleInternalParser { 
    before Label_StateMachine_49:analyze(boolean)
  {
        secondPostTokenAnalysis();
      }  
  } 

  class UmpleInternalParser { 
    before Label_StateMachine_56:analyzeToken(Token,int)
  {
      analyzeStateMachineToken(t,analysisStep);
    }  } 


  class UmpleInternalParser { 
    before Label_StateMachine_66:analyzeToken(Token,UmpleClass,int)
  {
      analyzeStateMachineToken(t,aClass,analysisStep);
    }  } 


// File UmpleAnalysis.ump:
  class GuardAnalyzer
  {
    isA Analyzer;
    depend cruise.umple.parser.analysis.Analyzer;
    depend cruise.umple.parser.Token;
    depend cruise.umple.compiler.*;
    depend java.util.*;
    ConstraintTree rawLine = new ConstraintTree();
    lazy UmpleClassifier uClassifier;
    lazy Transition t;
    
    void analyze(Token token)
    {
      Guard constraint = new Guard();
      constraint.addElementAll(rawLine.getRoot());
      constraint.setPosition(token.getPosition());
      constraint.setEndPosition(token.getEndPosition());

      t.setGuard(constraint);
      rawLine = new ConstraintTree();
    }
  }

// File UmpleAnalysis.ump:

class StatemachineExprAnalyzer
{
  isA Analyzer;
  depend cruise.umple.parser.analysis.Analyzer;
  depend cruise.umple.parser.Token;
  depend cruise.umple.compiler.*;
  depend java.util.*;
  lazy ConstraintTree rawLine;
  lazy UmpleClassifier uClassifier;
  ConstraintTree cv = null;
  boolean isStateMachine = true;
  public void prepare(Token token)
  {
    cv = rawLine.createNew();
  }
}

class StatemachineExprStateNameAnalyzer
{
  isA Analyzer;
  depend cruise.umple.parser.analysis.Analyzer;
  depend cruise.umple.parser.Token;
  depend cruise.umple.compiler.*;
  depend java.util.*;
  lazy UmpleClassifier uClassifier;  
  lazy ConstraintTree cv;
  ConstraintTree rawLine = null;

  public void prepare(Token token)
  {
    rawLine = cv.createNew();
  }
  public void analyze(Token token)
  {
    StateMachine stateMachine = null;
    while(!(cv.getRoot() instanceof ConstraintStateMachine))
    {
      if(cv.getRoot()!=null&&(cv.getRoot() instanceof ConstraintOperator))
      {
        ConstraintOperator operator = (ConstraintOperator)cv.getRoot();
        if(operator.getLeft()!=null&&(operator.getLeft() instanceof ConstraintTree))
        {
          cv = (ConstraintTree)operator.getLeft();
        }
        else break;
      }
      else break;
    }
    if(cv.getRoot() instanceof ConstraintStateMachine)
    {
      State state = ((ConstraintStateMachine)cv.getRoot()).getStateMachine().findState(token.getValue());
      ConstraintState var = new ConstraintState(state);
      rawLine.addElement(var);
    }
    else
    {
      //TODO: add error
    }
  }

}


  class ConstraintNameNameAnalyzer { 
    before Label_StateMachine_43:generateConstraintName(UmpleClassifier,String,Boolean)
  {
        StateMachine stateMachine = null;
        if(uClassifier instanceof UmpleClass)
        {
          stateMachine = ((UmpleClass)uClassifier).getStateMachine(value);
        }
        }  
} 

class ConstraintNameNameAnalyzer { 
    before Label_StateMachine_45:generateConstraintName(UmpleClassifier,String,Boolean)
  {
        if(stateMachine!=null)
        {
          ConstraintStateMachine name = new ConstraintStateMachine(stateMachine);
          return name;
        }
        }  } 
} 
