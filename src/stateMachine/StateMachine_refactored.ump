  class UmpleInternalParser {
    before Label_StateMachine_142:postTokenClassEnumerationAnalysis(UmpleClass)
    {
      // Check if the enumeration conflicts with any state machines, and if the enumeration is used as
      // event parameters
      for (StateMachine sm : uClass.getStateMachines()) {
        if (uEnum.hasSameName(sm.getName())) {
          // Enumeration Conflicts with State Machine Error
          getParseResult().addErrorMessage(new ErrorMessage(97,
                                                            uEnum.getPosition(),
                                                            uEnum.getName(),
                                                            "" + uEnum.getPosition().getLineNumber(),
                                                            sm.getName(),
                                                            uClass.getName()));
          return;
        }
        for (Event e : sm.getAllEvents()) {
          for (MethodParameter p : e.getParams()) {
            if (uEnum.hasSameName(p.getType()) && otherClass != null) {
              // Event Parameter Ambiguity Warning
              getParseResult().addErrorMessage(new ErrorMessage(103,
                                                                uEnum.getPosition(),
                                                                uEnum.getName(),
                                                                "" + uEnum.getPosition().getLineNumber(),
                                                                p.getName(),
                                                                e.getName(),
                                                                sm.getName(),
                                                                otherClass.getName()));
            }
          }
        }
      }
    }
  }



  class UmpleInternalParser {
    before Label_StateMachine_143:analyzeModelEnumInClass(UmpleClass,UmpleEnumeration)
    {
      // Check if the class's state machines conflict with the enumeration, and if any of its state
      // machine's events use the enumeration in their parameters
      for (StateMachine sm : uClass.getStateMachines()) {
        if (classUsesEnum) {
          if (uEnum.hasSameName(sm.getName())) {
            // Enumeration Conflicts with State Machine Error
            getParseResult().addErrorMessage(new ErrorMessage(97,
                                                              uEnum.getPosition(),
                                                              uEnum.getName(),
                                                              "" + uEnum.getPosition().getLineNumber(),
                                                              sm.getName(),
                                                              uClass.getName()));
            return;
          }
        }
        for (Event e : sm.getAllEvents()) {
          for (MethodParameter p : e.getParams()) {
            if (uEnum.hasSameName(p.getType())) {
              if (!classUsesEnum && uEnum.hasSameName(sm.getName())) {
                // Enumeration Conflicts with State Machine Error
                getParseResult().addErrorMessage(new ErrorMessage(97,
                                                                 uEnum.getPosition(),
                                                                 uEnum.getName(),
                                                                 "" + uEnum.getPosition().getLineNumber(),
                                                                 sm.getName(),
                                                                 uClass.getName()));
                return;
              }
              else {
                classUsesEnum = true;
              }
            }
          }
        }
      }
    }
  }


  class UmpleInternalParser { 
    before Label_StateMachine_49:analyze(boolean)
  {
        secondPostTokenAnalysis();
      }  
  } 

  class UmpleInternalParser { 
    before Label_StateMachine_56:analyzeToken(Token,int)
  {
      analyzeStateMachineToken(t,analysisStep);
    }  } 


  class UmpleInternalParser { 
    before Label_StateMachine_66:analyzeToken(Token,UmpleClass,int)
  {
      analyzeStateMachineToken(t,aClass,analysisStep);
    }  } 


// File UmpleAnalysis.ump:
  class GuardAnalyzer
  {
    isA Analyzer;
    depend cruise.umple.parser.analysis.Analyzer;
    depend cruise.umple.parser.Token;
    depend cruise.umple.compiler.*;
    depend java.util.*;
    ConstraintTree rawLine = new ConstraintTree();
    lazy UmpleClassifier uClassifier;
    lazy Transition t;
    
    void analyze(Token token)
    {
      Guard constraint = new Guard();
      constraint.addElementAll(rawLine.getRoot());
      constraint.setPosition(token.getPosition());
      constraint.setEndPosition(token.getEndPosition());

      t.setGuard(constraint);
      rawLine = new ConstraintTree();
    }
  }

// File UmpleAnalysis.ump:

class StatemachineExprAnalyzer
{
  isA Analyzer;
  depend cruise.umple.parser.analysis.Analyzer;
  depend cruise.umple.parser.Token;
  depend cruise.umple.compiler.*;
  depend java.util.*;
  lazy ConstraintTree rawLine;
  lazy UmpleClassifier uClassifier;
  ConstraintTree cv = null;
  boolean isStateMachine = true;
  public void prepare(Token token)
  {
    cv = rawLine.createNew();
  }
}

class StatemachineExprStateNameAnalyzer
{
  isA Analyzer;
  depend cruise.umple.parser.analysis.Analyzer;
  depend cruise.umple.parser.Token;
  depend cruise.umple.compiler.*;
  depend java.util.*;
  lazy UmpleClassifier uClassifier;  
  lazy ConstraintTree cv;
  ConstraintTree rawLine = null;

  public void prepare(Token token)
  {
    rawLine = cv.createNew();
  }
  public void analyze(Token token)
  {
    StateMachine stateMachine = null;
    while(!(cv.getRoot() instanceof ConstraintStateMachine))
    {
      if(cv.getRoot()!=null&&(cv.getRoot() instanceof ConstraintOperator))
      {
        ConstraintOperator operator = (ConstraintOperator)cv.getRoot();
        if(operator.getLeft()!=null&&(operator.getLeft() instanceof ConstraintTree))
        {
          cv = (ConstraintTree)operator.getLeft();
        }
        else break;
      }
      else break;
    }
    if(cv.getRoot() instanceof ConstraintStateMachine)
    {
      State state = ((ConstraintStateMachine)cv.getRoot()).getStateMachine().findState(token.getValue());
      ConstraintState var = new ConstraintState(state);
      rawLine.addElement(var);
    }
    else
    {
      //TODO: add error
    }
  }

}


  class ConstraintNameNameAnalyzer { 
    before Label_StateMachine_43:generateConstraintName(UmpleClassifier,String,Boolean)
  {
        StateMachine stateMachine = null;
        if(uClassifier instanceof UmpleClass)
        {
          stateMachine = ((UmpleClass)uClassifier).getStateMachine(value);
        }
        }  
} 

class ConstraintNameNameAnalyzer { 
    before Label_StateMachine_45:generateConstraintName(UmpleClassifier,String,Boolean)
  {
        if(stateMachine!=null)
        {
          ConstraintStateMachine name = new ConstraintStateMachine(stateMachine);
          return name;
        }
        }  } 
} 



// Fragment source file: Umple.ump
// Line : 111
 class UmpleModel { 1 -> * StateMachine stateMachineDefinitions; } 

// Fragment source file: Umple.ump
// Line : 519
 class ConstraintState { State state;
      key { state } } 

// Fragment source file: Umple.ump
// Line : 530
 class ConstraintStateMachine { StateMachine stateMachine;
      key { stateMachine } } 

// Fragment source file: Umple.ump
// Line : 757
 class UmpleClass { before addStateMachine { if (isImmutable()) { return false; } } } 

// Fragment source file: Umple.ump
// Line : 841
 class UmpleTrait { before addStateMachine { if (isImmutable()) { return false; } } } 

// Fragment source file: Umple.ump
// Line : 866
 class GeneralTPApplied { 1 -> * StateMachineTemplateSignature;
	1 -> * StateMachineModifier; } 

// Fragment source file: Umple.ump
// Line : 878
class StateMachineTemplateSignature{
	modifier;
	srcStateMachine;
	desStateMachine;
	String[] srcStates;
	String[] desStates;
	0..1 -> 0..1 MethodTemplateSignature;
	alias;
}


// File GraphWalking.ump:

  class StateMachineGraph 
  {
    depend cruise.umple.util.*;
    depend java.util.*;
    isA Graph;
    smName;
    boolean isNested;
  }


  // File GraphWalking_Code.ump:
  class StateMachineGraph 
  {
    // Constructor for Nested state machines
    public StateMachineGraph(Node startNode, String smName, boolean isDepthFirst) 
    {
      if (startNode != null)
      {
        this.startNode = startNode;
        this.startNode.visit();
      }
      this.smName = smName;
      this.isDepthFirst = isDepthFirst;
      this.isNested = true;

      if(isDepthFirst) 
      {
        this.stack = new Stack<Node>();
        this.stack.push(this.startNode);
      }
      else
      {
        this.queue = new LinkedList<Node>();
        this.queue.addFirst(this.startNode);
      }
    }

    // Constructor for flat state machines
    public StateMachineGraph(Node startNode, boolean isDepthFirst)
    {
      if (startNode != null)
      {
        this.startNode = startNode;
        this.startNode.visit();
      }

      this.isDepthFirst = isDepthFirst;
      this.isNested = false;

      if(isDepthFirst)
      {
        this.stack = new Stack<Node>();
        this.stack.push(this.startNode);
      }
      else
      {
        this.queue = new LinkedList<Node>();
        this.queue.addFirst(this.startNode);
      }
    }

    public Node nextNode() 
    {
      if (startNode == null) return null;
      if (this.isDepthFirst) return walkDFS();
      return walkBFS();
    }

    public void clearNodes()
    {
      if (startNode == null) return;

      HashSet<Node> visited = new HashSet<Node>();
      Stack<Node> nodes = new Stack<Node>();
      nodes.push(startNode);
      visited.add(startNode);

      while (! nodes.isEmpty())
      {
        State state = (State) nodes.pop();
        
        for (Transition transition: state.getTransitions()) 
        {
          State nextState = (State) transition.getNextState();
          StateMachine sm = nextState.getStateMachine();

          if ((! visited.contains(nextState)) && (!isNested || sm.getName().equals(this.smName)))
          {
            visited.add(nextState);
            nextState.clear();
            nodes.push(nextState) ;
          }
        }
      }
      if (this.isDepthFirst)
      {
        this.stack.clear();
        this.stack.push(this.startNode);
      }
      else
      {
        this.queue.clear();
        this.queue.addFirst(this.startNode);
      }
    }

    private Node walkDFS () 
    { 
      if (stack == null || stack.isEmpty()) return null;
      State state = (State) stack.pop();
      
      for (Transition transition: state.getTransitions()) 
      {
        State nextState = (State) transition.getNextState();
        StateMachine sm = nextState.getStateMachine();

        if ((! nextState.getIsVisited()) && (!isNested || sm.getName().equals(this.smName)))
        {
          nextState.visit();
          stack.push(nextState) ;
        }
      }

      return state;
    }

    private Node walkBFS () 
    {
      if (queue == null || queue.isEmpty()) return null;
      State state = (State) queue.pollLast();
      state.visit();

      for (Transition transition: state.getTransitions()) 
      {
        State nextState = (State) transition.getNextState();
        StateMachine sm = nextState.getStateMachine();
        if ((! nextState.getIsVisited()) && (!isNested || sm.getName().equals(this.smName)))
        {
          nextState.visit();
          queue.addFirst(nextState);
        }
      }

      return state;
    }
  }

// Fragment source file: Generator.ump
// Line : 44
interface CodeTranslator {
    String translate(String id, StateMachine stm);
    String translate(String id, State st);
    String translate(String id, Event e);
    String translate(String id, Activity a);
  }